// Generated by Haxe 4.1.5
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	matchSub(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			let b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			let b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
	split(s) {
		let d = "#__delim__#";
		return s.replace(this.r,d).split(d);
	}
	map(s,f) {
		let offset = 0;
		let buf_b = "";
		while(true) {
			if(offset >= s.length) {
				break;
			} else if(!this.matchSub(s,offset)) {
				buf_b += Std.string(HxOverrides.substr(s,offset,null));
				break;
			}
			let p = this.matchedPos();
			buf_b += Std.string(HxOverrides.substr(s,offset,p.pos - offset));
			buf_b += Std.string(f(this));
			if(p.len == 0) {
				buf_b += Std.string(HxOverrides.substr(s,p.pos,1));
				offset = p.pos + 1;
			} else {
				offset = p.pos + p.len;
			}
			if(!this.r.global) {
				break;
			}
		}
		if(!this.r.global && offset > 0 && offset < s.length) {
			buf_b += Std.string(HxOverrides.substr(s,offset,null));
		}
		return buf_b;
	}
}
EReg.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class djNode_BaseApp {
	constructor() {
		if(djNode_BaseApp._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.argsAction = null;
		this.argsOptions = { };
		this.argsOutput = null;
		this.argsInput = [];
		this.ARGS = { inputRule : "no", outputRule : "no", requireAction : false, supportWildcards : true, helpInput : null, helpOutput : null, helpText : null, Actions : [], Options : []};
		this.PROGRAM_INFO = { name : "CLI Application", version : "0.1"};
		this.HELP_MARGIN = 16;
		djNode_BaseApp.app = this;
		this.set_FLAG_USE_SLASH_FOR_OPTION(false);
		djNode_tools_LOG.init();
		djNode_BaseApp.TERMINAL = new djNode_Terminal();
		this.T = djNode_BaseApp.TERMINAL;
		let _gthis = this;
		process.once("exit",function(code) {
			djNode_tools_LOG.log("==> [EXIT] with code " + code);
			_gthis.onExit(code);
		});
		process.once("SIGINT",function() {
			process.exit(1223);
		});
		try {
			this.init();
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(typeof(_g1) == "string") {
				let e = _g1;
				this.printBanner(true);
				if(e == "HELP") {
					this.printHelp();
					process.exit(0);
				}
				this.exitError(e,true);
			} else {
				throw _g;
			}
		}
		djNode_tools_LOG.log("- Inputs : " + this.argsInput.join(", "));
		djNode_tools_LOG.log("- Output : " + this.argsOutput);
		djNode_tools_LOG.log("- Action  set : " + this.argsAction);
		djNode_tools_LOG.log("- Options set : ");
		let _g = 0;
		let _g1 = Reflect.fields(this.argsOptions);
		while(_g < _g1.length) {
			let o = _g1[_g];
			++_g;
			djNode_tools_LOG.log("\t\t" + o + " : " + Std.string(Reflect.getProperty(this.argsOptions,o)));
		}
		djNode_tools_LOG.log(djA_StrT.rep(40,"─"));
		process.nextTick($bind(this,this.onStart));
	}
	set_FLAG_USE_SLASH_FOR_OPTION(v) {
		this.FLAG_USE_SLASH_FOR_OPTION = v;
		if(v) {
			this._sb = ["/","?"];
		} else {
			this._sb = ["-","help"];
		}
		return v;
	}
	init() {
		let _this = this.T;
		process.stdout.write("\x1B[0m");
		this.ARGS.Options.unshift(["o","-output","yes"]);
		let P = this.PROGRAM_INFO;
		let A = this.ARGS;
		if(P.executable == null) {
			P.executable = js_node_Path.basename(__filename);
		}
		djNode_tools_LOG.log("Creating Application [ " + P.name + " ,v" + P.version + " ]");
		let cc = 0;
		let $arguments = process.argv.slice(2);
		let arg;
		while(true) {
			arg = $arguments[cc++];
			if(!(arg != null)) {
				break;
			}
			if(arg.charAt(0) == this._sb[0]) {
				if(arg.toLowerCase().indexOf(this._sb[1]) == 1) {
					throw haxe_Exception.thrown("HELP");
				}
				let o = this.getArgOption(HxOverrides.substr(arg,1,null));
				if(o == null) {
					throw haxe_Exception.thrown("Illegal argument [" + arg + "]");
				}
				if(o[2] != null) {
					let nextArg = $arguments[cc++];
					if(nextArg == null || this.getArgOption(nextArg) != null) {
						throw haxe_Exception.thrown("Argument [" + arg + "] requires a parameter");
					}
					this.argsOptions[o[0]] = nextArg;
				} else {
					this.argsOptions[o[0]] = true;
				}
				continue;
			}
			let a = this.getArgAction(arg);
			if(a != null) {
				if(this.argsAction != null) {
					throw haxe_Exception.thrown("You can only set one <action>");
				}
				this.argsAction = a[0];
				continue;
			}
			this.argsInput.push(arg);
		}
		if(this.argsOptions.o != null) {
			this.argsOutput = this.argsOptions.o;
		}
		let _g = 0;
		let _g1 = this.argsInput;
		while(_g < _g1.length) {
			let i = _g1[_g];
			++_g;
			if(i.indexOf("*") >= 0) {
				if(this.argsInput.length > 1) {
					throw haxe_Exception.thrown("Multiple Inputs with wildcards are not supported");
				}
				this.argsInput = djNode_tools_FileTool.getFileListFromWildcard(i);
				if(this.argsInput.length == 0) {
					throw haxe_Exception.thrown("Wildcard `" + i + "` returned 0 files");
				}
				break;
			}
		}
		if(this.argsAction == null && this.argsInput.length > 0) {
			let act = this.getArgAction(null,HxOverrides.substr(js_node_Path.extname(this.argsInput[0].toLowerCase()),1,null));
			if(act != null) {
				this.argsAction = act[0];
			}
		}
		if(this.argsInput.length == 0 && ["yes","multi"].indexOf(A.inputRule) >= 0) {
			throw haxe_Exception.thrown("Input is required");
		}
		if(this.argsOutput == null && A.outputRule == "yes") {
			throw haxe_Exception.thrown("Output is required");
		}
		if(A.requireAction && this.argsAction == null) {
			throw haxe_Exception.thrown("Setting an action is required");
		}
		let _g2 = 0;
		let _g3 = this.ARGS.Options;
		while(_g2 < _g3.length) {
			let o = _g3[_g2];
			++_g2;
			if(o[2] == null) {
				if(!Object.prototype.hasOwnProperty.call(this.argsOptions,o[0])) {
					this.argsOptions[o[0]] = false;
				}
			}
		}
	}
	onStart() {
	}
	onExit(code) {
		djNode_tools_LOG.end();
		let _this = this.T;
		process.stdout.write("\x1B[0m");
		this.T.cursorShow();
	}
	printHelp() {
		let A = this.ARGS;
		let P = this.PROGRAM_INFO;
		let _gthis = this;
		let sp = function(s) {
			return djA_StrT.rep(s," ");
		};
		let __getInfoRule = function(rule) {
			if(rule == "opt") {
				return "is optional.";
			} else {
				return "is required.";
			}
		};
		let __fixDescFormat = function(s,b) {
			let S;
			if(djA_StrT.isEmpty(s)) {
				S = "...";
			} else {
				let _this_r = new RegExp("(\n)","g".split("u").join(""));
				let by = "\n " + sp(_gthis.HELP_MARGIN);
				S = s.replace(_this_r,by);
			}
			let g = S.split("\n");
			g[0] += b;
			return g.join("\n");
		};
		this.T.ptag("<green> Program Usage:\n");
		let s = "   " + P.executable + " ";
		if(A.Actions.length > 0) {
			s += "<action> ";
		}
		if(A.Options.length > 1) {
			s += "[<options>...] ";
		}
		if(A.inputRule != "no") {
			s += A.inputRule == "multi" ? "[<inputs>...] " : "<input> ";
		}
		if(A.outputRule != "no") {
			s += this._sb[0] + "o <output> ";
		}
		let _this = this.T.ptag("<bold,white>" + s + "<!>\n").fg(djNode_TColor.darkgray);
		let str = djA_StrT.rep(40,"─");
		process.stdout.write(str + "\n");
		let _pp = false;
		if(A.inputRule != "no") {
			_pp = true;
			this.T.ptag("<yellow> [input] <!>");
			let _this = this.T;
			let str = __getInfoRule(A.inputRule);
			process.stdout.write(str);
			if(A.inputRule == "multi") {
				this.T.ptag("<darkgray> (multiple supported)");
			}
			let _this1 = this.T;
			process.stdout.write("\n");
			if(A.helpInput != null) {
				let _this_r = new RegExp("(\n)","g".split("u").join(""));
				A.helpInput = "<gray>\t " + A.helpInput.replace(_this_r,"\n\t ");
				let _this = this.T.ptag(A.helpInput);
				process.stdout.write("\n");
			}
		}
		if(A.outputRule != "no") {
			_pp = true;
			this.T.ptag("<yellow> [output] <!>");
			let _this = this.T;
			let str = __getInfoRule(A.outputRule);
			process.stdout.write(str);
			let _this1 = _this;
			process.stdout.write("\n");
			if(A.helpOutput != null) {
				let _this_r = new RegExp("(\n)","g".split("u").join(""));
				A.helpOutput = "<gray>\t " + A.helpOutput.replace(_this_r,"\n\t ");
				let _this = this.T.ptag(A.helpOutput);
				process.stdout.write("\n");
			}
		}
		if(_pp) {
			let _this = this.T.ptag(" <darkgray>" + djA_StrT.rep(40,"─"));
			process.stdout.write("\n");
		}
		let _this1 = this.T;
		process.stdout.write("\x1B[0m");
		if(A.Actions.length > 0) {
			this.T.ptag("<magenta> [actions] ");
			this.T.ptag("<darkmagenta>(you can set one action at a time)<!>\n");
			let _g = 0;
			let _g1 = A.Actions;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(i[1].charAt(0) == "-") {
					continue;
				}
				i[1] = __fixDescFormat(i[1],i[2] == null ? "" : "<darkgray> | auto ext:[" + i[2] + "] <!>");
				this.T.fg(djNode_TColor.white).bold();
				let _this = this.T.ptag(" " + i[0] + sp(this.HELP_MARGIN - i[0].length));
				process.stdout.write("\x1B[0m");
				_this.ptag(i[1]);
				let _this1 = this.T;
				process.stdout.write("\n");
			}
		}
		if(A.Options.length > 1) {
			this.T.ptag("<cyan> [options] ");
			this.T.ptag("<darkcyan>(you can set multiple options)<!>\n");
			let _g = 0;
			let _g1 = A.Options;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(i[1].charAt(0) == "-") {
					continue;
				}
				i[1] = __fixDescFormat(i[1],i[2] == null ? "" : "<darkgray> (requires parameter) <!>");
				this.T.fg(djNode_TColor.white).bold();
				let _this = this.T.ptag(" " + this._sb[0] + i[0] + sp(this.HELP_MARGIN - i[0].length - 1));
				process.stdout.write("\x1B[0m");
				_this.ptag(i[1]);
				let _this1 = this.T;
				process.stdout.write("\n");
			}
		}
		if(this.ARGS.helpText != null) {
			let _this = this.T;
			process.stdout.write("\n");
			this.T.ptag("" + this.ARGS.helpText + "\n");
		}
	}
	printBanner(longer) {
		if(longer == null) {
			longer = false;
		}
		let P = this.PROGRAM_INFO;
		let col = "cyan";
		let _this = this.T;
		process.stdout.write("\n");
		this.T.ptag("<:" + col + ",black>==<!><" + col + ",bold> " + P.name + " <darkgray>v" + P.version + "<!>");
		if(longer) {
			if(P.author != null) {
				this.T.ptag(" by " + P.author);
			}
			let _this = this.T;
			process.stdout.write("\n");
			if(P.info != null) {
				this.T.ptag(" - " + P.info + "\n");
			}
			if(P.desc != null) {
				this.T.ptag(" - " + P.desc + "\n");
			}
		} else {
			let _this = this.T;
			process.stdout.write("\n");
		}
		this.T.ptag("<" + Std.string(djNode_TColor.darkgray) + ">" + djA_StrT.rep(40,"─") + "<!>\n");
	}
	getArgOption(tag) {
		let _g = 0;
		let _g1 = this.ARGS.Options;
		while(_g < _g1.length) {
			let o = _g1[_g];
			++_g;
			if(o[0] == tag) {
				return o;
			}
		}
		return null;
	}
	getArgAction(tag,ext) {
		let _g = 0;
		let _g1 = this.ARGS.Actions;
		while(_g < _g1.length) {
			let a = _g1[_g];
			++_g;
			if(tag != null && a[0] == tag) {
				return a;
			}
			if(ext != null && a[2] != null) {
				if(a[2].split(",").indexOf(ext.toLowerCase()) >= 0) {
					return a;
				}
			}
		}
		return null;
	}
	exitError(text,showHelp) {
		if(showHelp == null) {
			showHelp = false;
		}
		this.T.ptag("\n<:darkred,white> ERROR <!> " + text + "<!>\n");
		if(showHelp) {
			this.T.ptag("<darkgray>" + djA_StrT.rep(40,"─") + ("\n<yellow> " + this._sb[0] + this._sb[1] + " <!> for usage info\n"));
		}
		djNode_tools_LOG.FLAG_STDOUT = false;
		djNode_tools_LOG.log(this.T.PARSED_NOTAG,4);
		process.exit(1);
	}
	isAdmin() {
		let res = djNode_utils_CLIApp.quickExecS("fsutil dirty query %systemdrive% >nul");
		return res != null;
	}
	autoCallAction() {
		let fn = Reflect.field(this,"action_" + this.argsAction);
		if(fn != null && Reflect.isFunction(fn)) {
			return fn.apply(this,[]);
		}
		return null;
	}
	waitKeyQuit() {
		this.T.ptag("\n<darkgray>Press any key to quit.<!>\n");
		djNode_Keyboard.startCapture(true,function(e) {
			process.exit(0);
		});
	}
	getAppPathJoin(p) {
		return js_node_Path.join(__dirname,p);
	}
}
djNode_BaseApp.__name__ = true;
Object.assign(djNode_BaseApp.prototype, {
	__properties__: {set_FLAG_USE_SLASH_FOR_OPTION: "set_FLAG_USE_SLASH_FOR_OPTION"}
});
class Main extends djNode_BaseApp {
	constructor() {
		djNode_BaseApp._hx_skip_constructor = true;
		super();
		djNode_BaseApp._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.PATH_CDC = "";
		super._hx_constructor();
	}
	ffmpeg_check() {
		return djNode_utils_CLIApp.checkRun("ffmpeg -version");
	}
	do_crushAsync(cueFile,outDir,onComplete) {
		this.p.p("<cyan>Encoding with CDCRUSH<!,cs>");
		let _gthis = this;
		let proc = js_node_ChildProcess.fork("" + this.PATH_CDC,["-fork","c","-enc","-ac","vorbis:1",cueFile,"-o",outDir],{ silent : true});
		proc.on("message",function(s) {
			switch(s.msg) {
			case "complete":
				let _this = _gthis.T;
				process.stdout.write("\x1B[u");
				_this.clearLine(0);
				let _this1 = _gthis.T;
				process.stdout.write(" [OK]" + "\n");
				onComplete();
				break;
			case "progress":
				let _this2 = _gthis.T;
				process.stdout.write("\x1B[u");
				_this2.clearLine(0);
				let prog = s.progress | 0;
				let _this3 = _gthis.T;
				process.stdout.write(" " + prog + " %");
				break;
			case "start":
				break;
			default:
			}
		});
	}
	do_cfs(Files,cfsFile,complete) {
		this.p.p("<cyan>Converting to CFS<!,cs> ");
		let _gthis = this;
		djNode_app_PismoMount.CFS_CreateAsync(Files,cfsFile,function(ok) {
			let _this = _gthis.T;
			process.stdout.write("\x1B[u");
			_this.clearLine(0);
			let _this1 = _gthis.T;
			process.stdout.write(" [OK]" + "\n");
			complete();
		},function(p) {
			let _this = _gthis.T;
			process.stdout.write("\x1B[u");
			_this.clearLine(0);
			let _this1 = _gthis.T;
			process.stdout.write(" " + p + " %");
		});
	}
	do_printCFSInfo(cfsFile) {
		let size = djA_DataT.bytesToMBStr(js_node_Fs.statSync(cfsFile).size | 0);
		this.p.p("CFS Size : <yellow>" + size + " MB<!>");
	}
	do_deleteRDir(rdirs) {
		let _g = 0;
		while(_g < rdirs.length) {
			let dir = rdirs[_g];
			++_g;
			djNode_tools_FileTool.deleteRecursiveDir(dir);
		}
	}
	prepareCUE(cueFile,OutDir,complete) {
		let cd = new cd_CDInfos();
		let t0 = "<yellow>{1}<!> : {2}";
		try {
			cd.cueLoad(cueFile);
			this.T.ptag("<blue> >> FILE<!> : <green>" + cueFile + "<!>\n");
			this.p.ptem(t0,"TITLE",cd.CD_TITLE);
			this.p.ptem(t0,"TRACKS",cd.tracks.length);
			this.p.ptem(t0,"SIZE",djA_DataT.bytesToMBStr(cd.CD_TOTAL_SIZE) + " MB");
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(typeof(_g1) == "string") {
				let e = _g1;
				this.exitError(e);
			} else {
				throw _g;
			}
		}
		let filesToCFS = [];
		if(cd.tracks.length == 1) {
			filesToCFS.push(cueFile);
			let _g = 0;
			let _g1 = cd.tracks;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				filesToCFS.push(i.workingFile);
			}
			complete(filesToCFS,null);
		} else {
			let cdcOut = js_node_Path.join(OutDir,"cdtocfs_temp_" + new Date().getTime());
			this.do_crushAsync(cueFile,cdcOut,function() {
				let newDir = js_node_Path.join(cdcOut,"" + cd.CD_TITLE + " (r)");
				let _g = 0;
				let _g1 = djNode_tools_FileTool.getFileListFromDir(newDir);
				while(_g < _g1.length) {
					let f = _g1[_g];
					++_g;
					filesToCFS.push(js_node_Path.join(newDir,f));
				}
				complete(filesToCFS,cdcOut);
			});
		}
	}
	operation_CUE(file,OutDir,complete) {
		let _gthis = this;
		let TITLE = HxOverrides.substr(js_node_Path.basename(file),0,-4);
		let cfsPath = js_node_Path.join(OutDir,TITLE + ".cfs");
		if(djNode_tools_FileTool.pathExists(cfsPath)) {
			this.p.p("Output <yellow>CFS<!> file already exists.. <red>Skipping <!>");
			complete();
			return;
		}
		this.prepareCUE(file,OutDir,function(files,rdir) {
			_gthis.do_cfs(files,cfsPath,function() {
				if(rdir != null) {
					_gthis.do_deleteRDir([rdir]);
				}
				_gthis.do_printCFSInfo(cfsPath);
				_gthis.p.line();
				complete();
			});
		});
	}
	operation_M3U(m3uFile,OutDir,complete) {
		let _gthis = this;
		let TITLE = HxOverrides.substr(js_node_Path.basename(m3uFile),0,-4);
		let cfsPath = js_node_Path.join(OutDir,TITLE + ".cfs");
		this.p.H("M3U : " + TITLE + ".m3u",1);
		if(djNode_tools_FileTool.pathExists(cfsPath)) {
			this.p.p("Output <yellow>CFS<!> file already exists.. <red>Skipping <!>");
			complete();
			return;
		}
		let cueFiles = [];
		let _g = 0;
		let _g1 = js_node_Fs.readFileSync(m3uFile).toString().split(js_node_Os.EOL);
		while(_g < _g1.length) {
			let i = _g1[_g];
			++_g;
			cueFiles.push(js_node_Path.join(js_node_Path.dirname(m3uFile),i));
		}
		let allFiles = [m3uFile];
		let dirsToDel = [];
		let ar = new djA_ArrayExecSync(cueFiles);
		ar.onItem = function(file) {
			_gthis.prepareCUE(file,OutDir,function(files,rdir) {
				allFiles = allFiles.concat(files);
				if(rdir != null) {
					dirsToDel.push(rdir);
				}
				ar.next();
			});
		};
		ar.onComplete = function() {
			_gthis.do_cfs(allFiles,cfsPath,function() {
				if(dirsToDel.length > 0) {
					_gthis.do_deleteRDir(dirsToDel);
				}
				_gthis.do_printCFSInfo(cfsPath);
				_gthis.p.line();
				complete();
			});
		};
		ar.start();
	}
	onStart() {
		this.p = new djNode_utils_Print2();
		djNode_utils_Print2.H_STYLES[1] = { templ : "<:yellow,black> > <!> <yellow>{1}<!>", pad0 : 4, pad1 : 7, line : null};
		this.PATH_CDC = this.getAppPathJoin("cdcrush.js");
		djNode_app_PismoMount.CFS_SetExe();
		if(!djNode_tools_FileTool.pathExists(djNode_app_PismoMount.PTISO)) {
			this.exitError("ptiso.exe not found");
		}
		if(!this.ffmpeg_check()) {
			this.exitError("FFMPEG not found");
		}
		this.printBanner();
		let _gthis = this;
		let _this = this.T;
		process.stdout.write("\n");
		let ar = new djA_ArrayExecSync(this.argsInput);
		ar.onItem = function(f) {
			_gthis.p.H("Processing Queue ( " + (ar.C + 1) + " / " + ar.items.length + " ) ");
			if(!djNode_tools_FileTool.pathExists(f)) {
				_gthis.p.p("<yellow>\"" + f + "\"<!> <red> does not exist.");
				ar.next();
				return;
			}
			f = js_node_Path.resolve(f);
			f = js_node_Path.normalize(f);
			let OUTDIR = djA_DataT.existsOr(_gthis.argsOutput,js_node_Path.dirname(f));
			let ext = js_node_Path.extname(f.toLowerCase());
			if(ext == ".zip") {
				let newpath = djNode_app_PismoMount.mount(f);
				let files = djNode_tools_FileTool.getFileListFromDir(newpath,true);
				let _g = [];
				let _g1 = 0;
				let _g2 = files;
				while(_g1 < _g2.length) {
					let v = _g2[_g1];
					++_g1;
					if(js_node_Path.extname(v).toLowerCase() == ".cue") {
						_g.push(v);
					}
				}
				files = _g;
				if(files.length == 0) {
					_gthis.p.p("<red>CUE File not Found in the ZIP<!>");
					ar.next();
				} else {
					_gthis.operation_CUE(files[0],OUTDIR,function() {
						djNode_app_PismoMount.unmount(f);
						ar.next();
					});
				}
			} else if(ext == ".cue") {
				_gthis.operation_CUE(f,OUTDIR,$bind(ar,ar.next));
			} else if(ext == ".m3u") {
				_gthis.operation_M3U(f,OUTDIR,$bind(ar,ar.next));
			} else {
				_gthis.p.p("<red>Unsupported File Extension<!> : " + ext);
				ar.next();
			}
		};
		ar.start();
	}
	init() {
		this.PROGRAM_INFO = { name : "CUE to CFS", version : "0.2"};
		this.ARGS.Actions = [["m3u","Convert M3U\nThis will read all the .CUE files included in the .M3U playlist and\nconvert all of them into a single .CFS archive","m3u"],["cue","Convert CUE\nConvert a CUE file to a CFS file. If the CD has audio tracks,\nthey will be encoded to VORBIS.","cue"]];
		this.ARGS.helpText = "- Converts .cue files to .cfs for use with PISMO File Mount.\n" + "- You don't have to set an action, it will be guessed from the input file extension\n" + "- Simple Wildcards are supported, in this form only <yellow>*.cue<!> or <yellow>*.m3u<!>";
		this.ARGS.helpInput = "<darkyellow>cuetocfs *.cue<!> -> will convert all cue files in current dir\n" + "<darkyellow>cuetocfs game.m3u<!> -> Convert a single Game Playlist file to a Single.CFS archive";
		this.ARGS.helpOutput = "You can set an output directory to create the .cfs archives\n" + "<darkyellow>cuetocfs Game.cue -o c:\\PS1<!> -> Will convert Game.Cue to c:\\Ps1\\Game.cfs (dir will be created)";
		this.ARGS.requireAction = true;
		this.ARGS.inputRule = "multi";
		this.ARGS.outputRule = "opt";
		super.init();
	}
	static main() {
		new Main();
	}
}
Main.__name__ = true;
Math.__name__ = true;
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static getProperty(o,field) {
		let tmp;
		if(o == null) {
			return null;
		} else {
			let tmp1;
			if(o.__properties__) {
				tmp = o.__properties__["get_" + field];
				tmp1 = tmp;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				return o[tmp]();
			} else {
				return o[field];
			}
		}
	}
	static setProperty(o,field,value) {
		let tmp;
		let tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["set_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			o[tmp](value);
		} else {
			o[field] = value;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
	static isEnumValue(v) {
		if(v != null) {
			return v.__enum__ != null;
		} else {
			return false;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
}
Reflect.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = true;
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static lpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		l -= s.length;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		buf_b += s == null ? "null" : "" + s;
		return buf_b;
	}
	static rpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		buf_b += s == null ? "null" : "" + s;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class haxe_io_Output {
}
haxe_io_Output.__name__ = true;
class _$Sys_FileOutput extends haxe_io_Output {
	constructor(fd) {
		super();
		this.fd = fd;
	}
	writeByte(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	writeBytes(s,pos,len) {
		let data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	writeString(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	flush() {
		js_node_Fs.fsyncSync(this.fd);
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
}
_$Sys_FileOutput.__name__ = true;
class haxe_io_Input {
}
haxe_io_Input.__name__ = true;
class _$Sys_FileInput extends haxe_io_Input {
	constructor(fd) {
		super();
		this.fd = fd;
	}
	readByte() {
		let buf = js_node_buffer_Buffer.alloc(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		return buf[0];
	}
	readBytes(s,pos,len) {
		let data = s.b;
		let buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
}
_$Sys_FileInput.__name__ = true;
class Type {
	static createEnum(e,constr,params) {
		let f = Reflect.field(e,constr);
		if(f == null) {
			throw haxe_Exception.thrown("No such constructor " + constr);
		}
		if(Reflect.isFunction(f)) {
			if(params == null) {
				throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
			}
			return f.apply(e,params);
		}
		if(params != null && params.length != 0) {
			throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
		}
		return f;
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let ctorName = enm.__constructs__[e._hx_index];
		let params = enm[ctorName].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
Type.__name__ = true;
class cd_CDInfos {
	constructor() {
		this.CD_TITLE = "untitled";
		this.CD_TYPE = null;
		this.CD_AUDIO_QUALITY = null;
		this.CD_TOTAL_SIZE = 0;
		this.SECTOR_SIZE = 0;
		this.MULTIFILE = false;
		this.tracks = [];
		this.openTrack = null;
		this.openFile = null;
	}
	cueLoad(input) {
		cd_CDInfos.LOG("cueLoad(): Loading `" + input + "`");
		if(!sys_FileSystem.exists(input)) {
			throw haxe_Exception.thrown("File " + input + " does not exist.");
		}
		let input_dir = haxe_io_Path.directory(input);
		let input_ext = haxe_io_Path.extension(input).toLowerCase();
		if(input_ext != "cue") {
			throw haxe_Exception.thrown("File " + input + " must be a `.CUE` file.");
		}
		let fileContent = js_node_Fs.readFileSync(input,{ encoding : "utf8"});
		let fileData = fileContent.split("\n");
		let rtitle = new EReg("([^/\\\\]*)\\.cue$","i");
		if(rtitle.match(input)) {
			this.CD_TITLE = rtitle.matched(1);
		}
		cd_CDInfos.LOG("Guessed cd title = " + this.CD_TITLE);
		let _g = 0;
		let _g1 = fileData.length;
		while(_g < _g1) {
			let l = _g++;
			let line = fileData[l];
			if(line.length == 0) {
				continue;
			}
			line = StringTools.trim(line);
			try {
				this.cue_parser(line);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(typeof(_g1) == "string") {
					let e = _g1;
					throw haxe_Exception.thrown("Cue Parse Error ( Line " + l + " ) : " + e);
				} else {
					throw _g;
				}
			}
		}
		this.openTrack = null;
		if(this.tracks.length == 0) {
			throw haxe_Exception.thrown("No tracks in the .Cue file");
		}
		let _g2 = 0;
		let _g3 = this.tracks;
		while(_g2 < _g3.length) {
			let t = _g3[_g2];
			++_g2;
			if(t.isData) {
				this.CD_TYPE = t.trackType;
				break;
			}
		}
		if(this.CD_TYPE == null) {
			this.CD_TYPE = "AUDIO";
		}
		this.SECTOR_SIZE = cd_CDInfos.getSectorsByDataType(this.CD_TYPE);
		let cc = 0;
		let _g4 = 0;
		let _g5 = this.tracks;
		while(_g4 < _g5.length) {
			let t = _g5[_g4];
			++_g4;
			if(t.indexes.length == 0) {
				throw haxe_Exception.thrown("Track " + t.trackNo + " has no indexes defined");
			}
			if(t.trackFile == null) {
				continue;
			}
			++cc;
			t.workingFile = haxe_io_Path.join([input_dir,t.trackFile]);
			if(!sys_FileSystem.exists(t.workingFile)) {
				throw haxe_Exception.thrown("TrackFile " + t.trackFile + " is defined but does not exist");
			}
			let finfo = js_node_Fs.statSync(t.workingFile);
			t.byteSize = finfo.size;
			t.sectorSize = Math.ceil(t.byteSize / this.SECTOR_SIZE);
			if(t.sectorSize <= 0) {
				throw haxe_Exception.thrown("TrackFile " + t.trackFile + " is corrupted.");
			}
			this.CD_TOTAL_SIZE += t.byteSize;
		}
		if(cc == this.tracks.length && cc > 1) {
			cd_CDInfos.LOG("Multi-File CD Image");
			this.MULTIFILE = true;
			this.initTracks_SectorStart();
		} else if(cc == 1) {
			cd_CDInfos.LOG("Single-File CD image");
			this.MULTIFILE = false;
			let imSectorSize = this.tracks[0].sectorSize;
			let c = this.tracks.length - 1;
			this.tracks[c].initSectorStartFromIndex();
			this.tracks[c].sectorSize = imSectorSize - this.tracks[c].sectorStart;
			while(--c >= 0) {
				this.tracks[c].initSectorStartFromIndex();
				this.tracks[c].sectorSize = this.tracks[c + 1].sectorStart - this.tracks[c].sectorStart;
			}
			this.initTracks_byteSize();
		} else if(cc == 0) {
			throw haxe_Exception.thrown("There are no image files defined in the cuesheet");
		} else {
			throw haxe_Exception.thrown("Not Supported. Either one track file or all track files");
		}
	}
	cueSave(output,extraLines) {
		cd_CDInfos.LOG("Saving .cue, " + output);
		let GAP = "  ";
		if(this.tracks.length == 0) {
			throw haxe_Exception.thrown("There is no data to save");
		}
		let data = "";
		let tr;
		let i = 0;
		while(true) {
			tr = this.tracks[i];
			if(tr.trackFile != null) {
				let fileType;
				switch(haxe_io_Path.extension(tr.trackFile).toLowerCase()) {
				case "flac":
					fileType = "WAVE";
					break;
				case "mp3":
					fileType = "MP3";
					break;
				case "ogg":
					fileType = "OGG";
					break;
				case "tak":
					fileType = "WAVE";
					break;
				default:
					fileType = "BINARY";
				}
				data += "FILE \"" + tr.trackFile + "\" " + fileType + "\n";
			}
			let _st = StringTools.lpad("" + tr.trackNo,"0",2);
			data += "" + GAP + "TRACK " + _st + " " + tr.trackType + "\n";
			if(tr.pregap != null) {
				let _sp = tr.pregap.toString();
				data += "" + GAP + GAP + "PREGAP " + _sp + "\n";
			}
			let _g = 0;
			let _g1 = tr.indexes.length;
			while(_g < _g1) {
				let i = _g++;
				let _s0 = StringTools.lpad("" + tr.indexes[i].no,"0",2);
				let _s1 = tr.indexes[i].toString();
				data += "" + GAP + GAP + "INDEX " + _s0 + " " + _s1 + "\n";
			}
			if(!(++i < this.tracks.length)) {
				break;
			}
		}
		data += "REM ------------------------------\n";
		if(this.CD_AUDIO_QUALITY != null) {
			data += "REM Audio Quality : " + this.CD_AUDIO_QUALITY + "\n";
		}
		if(extraLines != null) {
			let _g = 0;
			while(_g < extraLines.length) {
				let l = extraLines[_g];
				++_g;
				data += "REM " + l + "\n";
			}
		}
		js_node_Fs.writeFileSync(output,data);
	}
	jsonLoad(input) {
		cd_CDInfos.LOG("jsonLoad(): Loading `" + input + "`");
		if(!sys_FileSystem.exists(input)) {
			throw haxe_Exception.thrown("File " + input + " does not exist.");
		}
		let obj = JSON.parse(js_node_Fs.readFileSync(input,{ encoding : "utf8"}));
		if(obj == null) {
			throw haxe_Exception.thrown("Can't parse parameters file");
		}
		let versionLoaded = 1;
		if(Object.prototype.hasOwnProperty.call(obj,"version")) {
			versionLoaded = obj.version;
		}
		let TR = obj.tracks;
		if(versionLoaded == 1) {
			let cdSecSize = obj.sectorSize;
			if(TR.length == 1) {
				TR[0].sectorSize = Math.ceil(obj.imageSize / cdSecSize);
			}
			let _g = 0;
			while(_g < TR.length) {
				let i = TR[_g];
				++_g;
				i.diskFileSize = i.sectorSize * cdSecSize;
			}
			++versionLoaded;
		}
		if(versionLoaded == 2) {
			let diskFiles = 0;
			let capturedAudio = "";
			let dt = null;
			let _g = 0;
			while(_g < TR.length) {
				let i = TR[_g];
				++_g;
				i.trackType = i.type;
				i.indexes = i.indexAr;
				i.storedFileName = i.filename;
				i.byteSize = i.diskFileSize;
				i.md5 = "-";
				if(dt == null && i.trackType != "AUDIO") {
					dt = i.trackType;
				}
				if(i.diskFile != null) {
					++diskFiles;
				}
				if(capturedAudio == null && i.trackType == "AUDIO") {
					capturedAudio = haxe_io_Path.extension(i.filename);
				}
			}
			if(capturedAudio != null) {
				if(capturedAudio == "ogg") {
					obj.audio = "Ogg Vorbis ??? k Vbr";
				}
				if(capturedAudio == "flac") {
					obj.audio = "FLAC Lossless";
				}
			} else {
				obj.audio = null;
			}
			obj.totalSize = obj.imageSize;
			obj.multiFile = diskFiles > 1 && diskFiles == TR.length;
			obj.cdType = dt == null ? "AUDIO" : dt;
			++versionLoaded;
		}
		if(versionLoaded == 3) {
			let _g = 0;
			while(_g < TR.length) {
				let i = TR[_g];
				++_g;
				if(i.pregapMinutes > 0 || i.pregapSeconds > 0 || i.pregapMillisecs > 0) {
					i.pregap = new cd_CueTime(0,i.pregapMinutes,i.pregapSeconds,i.pregapMillisecs);
				}
				let indexes = i.indexes;
				let _g1 = 0;
				while(_g1 < indexes.length) {
					let ii = indexes[_g1];
					++_g1;
					ii.frames = ii.millisecs;
					Reflect.deleteField(ii,"millisecs");
				}
			}
		}
		this.tracks = [];
		let _g = 0;
		while(_g < TR.length) {
			let i = TR[_g];
			++_g;
			let t = new cd_CDTrack();
			t.fromJSON(i);
			this.tracks.push(t);
		}
		this.CD_TITLE = obj.cdTitle;
		this.CD_TYPE = obj.cdType;
		this.CD_TOTAL_SIZE = obj.totalSize;
		this.CD_AUDIO_QUALITY = obj.audio;
		this.MULTIFILE = obj.multiFile;
		this.SECTOR_SIZE = obj.sectorSize;
		if(this.tracks[0].byteSize == 0) {
			this.initTracks_byteSize();
		}
		if(this.tracks.length > 1 && this.tracks[1].sectorStart == 0) {
			this.initTracks_SectorStart();
		}
	}
	jsonSave(output) {
		if(this.tracks.length == 0) {
			throw haxe_Exception.thrown("Warning , No tracks to save");
		}
		let _g = 0;
		let _g1 = this.tracks;
		while(_g < _g1.length) {
			let i = _g1[_g];
			++_g;
			if(i.storedFileName == null) {
				throw haxe_Exception.thrown("Track " + i.trackNo + " should have a filename set.");
			}
		}
		let o = cd_CDInfos.VERSION;
		let o1 = this.CD_TITLE;
		let o2 = this.CD_TYPE;
		let o3 = this.CD_AUDIO_QUALITY;
		let o4 = this.SECTOR_SIZE;
		let o5 = this.CD_TOTAL_SIZE;
		let o6 = this.MULTIFILE;
		let _g2 = [];
		let _g3 = 0;
		let _g4 = this.tracks;
		while(_g3 < _g4.length) {
			let t = _g4[_g3];
			++_g3;
			_g2.push(t.toJSON());
		}
		let o7 = { version : o, cdTitle : o1, cdType : o2, audio : o3, sectorSize : o4, totalSize : o5, multiFile : o6, tracks : _g2};
		js_node_Fs.writeFileSync(output,JSON.stringify(o7,null,"\t"));
	}
	initTracks_SectorStart() {
		if(this.tracks.length == 0) {
			return;
		}
		let last = 0;
		let _g = 0;
		let _g1 = this.tracks.length;
		while(_g < _g1) {
			let i = _g++;
			this.tracks[i].sectorStart = last;
			last += this.tracks[i].sectorSize;
		}
	}
	initTracks_byteSize() {
		if(this.tracks.length == 0) {
			return;
		}
		let _g = 0;
		let _g1 = this.tracks;
		while(_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			t.byteSize = t.sectorSize * this.SECTOR_SIZE;
		}
	}
	cue_parser(line) {
		if(new EReg("^FILE","i").match(line)) {
			this.openTrack = null;
			let q = new EReg("\"+","g").split(line);
			if(q.length < 3) {
				throw haxe_Exception.thrown("Could not read Track File");
			}
			let type = StringTools.trim(q.pop()).toUpperCase();
			if(cd_CDInfos.SUPPORTED_TRACK_FILES.indexOf(type) < 0) {
				throw haxe_Exception.thrown("Unsupported Track File Type " + type);
			}
			q.shift();
			this.openFile = q.join("");
			return;
		}
		let regTrack = new EReg("^\\s*TRACK\\s+(\\d+)\\s+(\\S+)","i");
		if(regTrack.match(line)) {
			this.openTrack = null;
			let _g = 0;
			let _g1 = this.tracks;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(i.trackNo == Std.parseInt(regTrack.matched(1))) {
					throw haxe_Exception.thrown("Track " + i.trackNo + " is already defined");
				}
			}
			let tr = new cd_CDTrack();
			tr.set(Std.parseInt(regTrack.matched(1)),regTrack.matched(2));
			tr.trackFile = this.openFile;
			this.openFile = null;
			this.openTrack = tr;
			this.tracks.push(tr);
			return;
		}
		let regIndex = new EReg("^\\s*INDEX\\s+(\\d+)\\s+(\\d{1,2}):(\\d{1,2}):(\\d{1,2})","i");
		if(regIndex.match(line)) {
			if(this.openTrack == null) {
				throw haxe_Exception.thrown("A Track is not defined yet");
			}
			let indexno = Std.parseInt(regIndex.matched(1));
			if(this.openTrack.indexExists(indexno)) {
				throw haxe_Exception.thrown("Track {" + Std.string(this.openTrack) + ".trackNo} " + (", Duplicate Index entry. Index(" + indexno + ")"));
			}
			this.openTrack.addIndex(indexno,Std.parseInt(regIndex.matched(2)),Std.parseInt(regIndex.matched(3)),Std.parseInt(regIndex.matched(4)));
			return;
		}
		let regPregap = new EReg("^\\s*PREGAP\\s+(\\d{1,2}):(\\d{1,2}):(\\d{1,2})","i");
		if(regPregap.match(line)) {
			if(this.openTrack == null) {
				throw haxe_Exception.thrown("A Track is not defined yet");
			}
			this.openTrack.setPregap(Std.parseInt(regPregap.matched(1)),Std.parseInt(regPregap.matched(2)),Std.parseInt(regPregap.matched(3)));
			return;
		}
		if(new EReg("^TITLE","i").match(line)) {
			if(this.openTrack != null) {
				return;
			}
			let r = new EReg(".+\"(.+)\"$","i");
			if(r.match(line)) {
				this.CD_TITLE = r.matched(1);
			} else {
				throw haxe_Exception.thrown("TITLE error");
			}
		}
	}
	getDetailedInfo() {
		let d1 = "Title\t:  " + this.CD_TITLE + " " + cd_CDInfos.NEWLINE + ("Type\t:  " + this.CD_TYPE + " " + cd_CDInfos.NEWLINE) + ("Audio\t:  " + this.CD_AUDIO_QUALITY + " " + cd_CDInfos.NEWLINE) + ("Tracks\t:  " + this.tracks.length + " " + cd_CDInfos.NEWLINE) + ("-------------------------------------------------- " + cd_CDInfos.NEWLINE) + (" #  Type       Pregap   Sectors  Size      MD5 " + cd_CDInfos.NEWLINE);
		let d2 = "";
		let totalSectors = 0;
		let _g = 0;
		let _g1 = this.tracks;
		while(_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			totalSectors += t.sectorSize;
			let s = " " + StringTools.rpad("" + t.trackNo," ",3) + StringTools.rpad(t.trackType," ",11) + (t.pregap != null ? StringTools.rpad(t.pregap.toString()," ",9) : "00:00:00 ") + StringTools.rpad("" + t.sectorSize," ",9) + StringTools.rpad("" + t.byteSize," ",10) + t.md5 + cd_CDInfos.NEWLINE;
			d2 += s;
		}
		d2 += "-------------------------------------------------- " + cd_CDInfos.NEWLINE + ("Total Sectors : " + totalSectors + " " + cd_CDInfos.NEWLINE) + ("Total Size    : " + this.CD_TOTAL_SIZE + " " + cd_CDInfos.NEWLINE);
		return d1 + d2;
	}
	LOGINFOS() {
	}
	static getSectorsByDataType(type) {
		switch(type) {
		case "AUDIO":
			return 2352;
		case "CDG":
			return 2352;
		case "CDI/2336":
			return 2336;
		case "CDI/2352":
			return 2352;
		case "MODE1/2048":
			return 2048;
		case "MODE1/2352":
			return 2352;
		case "MODE2/2336":
			return 2336;
		case "MODE2/2352":
			return 2352;
		default:
			throw haxe_Exception.thrown("Unsuported type " + type);
		}
	}
}
cd_CDInfos.LOG = function(s) {
};
cd_CDInfos.__name__ = true;
class cd_CDTrack {
	constructor() {
		this.indexes = [];
		this.pregap = null;
		this.trackNo = 0;
		this.set_trackType(null);
		this.sectorStart = 0;
		this.sectorSize = 0;
		this.byteSize = 0;
		this.md5 = "-";
		this.storedFileName = null;
		this.isData = false;
		this.workingFile = null;
		this.trackFile = null;
	}
	set(no,type) {
		this.trackNo = no;
		this.set_trackType(type);
		cd_CDInfos.getSectorsByDataType(this.trackType);
	}
	set_trackType(value) {
		this.trackType = value;
		if(this.trackType != null) {
			this.isData = this.trackType != "AUDIO";
		}
		return this.trackType;
	}
	initSectorStartFromIndex() {
		this.sectorStart = this.indexes[0].toFrames();
	}
	addIndex(no,min,sec,f) {
		this.indexes.push(new cd_CueTime(no,min,sec,f));
	}
	indexExists(indexNo) {
		let _g = 0;
		let _g1 = this.indexes;
		while(_g < _g1.length) {
			let i = _g1[_g];
			++_g;
			if(i.no == indexNo) {
				return true;
			}
		}
		return false;
	}
	setPregap(min,sec,f) {
		this.pregap = new cd_CueTime(0,min,sec,f);
	}
	rewriteIndexes_forMultiFile() {
		if(this.indexes.length == 0) {
			return;
		}
		let ms1 = this.indexes[0].toFrames();
		this.indexes[0].fromFrames(0);
		let _g = 1;
		let _g1 = this.indexes.length;
		while(_g < _g1) {
			let c = _g++;
			let ms2 = this.indexes[c].toFrames();
			let newtime = ms2 - ms1;
			this.indexes[c].fromFrames(newtime);
		}
	}
	rewriteIndexes_forSingleFile() {
		let old = this.indexes.slice();
		this.indexes = [];
		this.indexes.push(new cd_CueTime().fromFrames(this.sectorStart));
		let _g = 1;
		let _g1 = old.length;
		while(_g < _g1) {
			let i = _g++;
			this.indexes.push(new cd_CueTime(i).fromFrames(this.sectorStart + old[i].toFrames()));
		}
	}
	getTrackName() {
		return "track" + StringTools.lpad("" + this.trackNo,"0",2);
	}
	getFilenameRaw() {
		return this.getTrackName() + (this.isData ? ".bin" : ".pcm");
	}
	toString_() {
		let s = "";
		let _g = 0;
		let _g1 = this.indexes;
		while(_g < _g1.length) {
			let i = _g1[_g];
			++_g;
			s += Std.string(i) + ", ";
		}
		return "Track #" + this.trackNo + ", type:" + this.trackType + ", indexes:[" + s + "], size:" + this.byteSize + ", sectorStart:" + this.sectorStart + ", sectorSize:" + this.sectorSize + ", CueFile:" + this.trackFile + ", storedFile:" + this.storedFileName + ", md5:" + this.md5;
	}
	toJSON() {
		return { trackNo : this.trackNo, trackType : this.trackType, sectorStart : this.sectorStart, sectorSize : this.sectorSize, byteSize : this.byteSize, storedFileName : this.storedFileName, md5 : this.md5, pregap : this.pregap, indexes : this.indexes};
	}
	fromJSON(o) {
		let _g = 0;
		let _g1 = Reflect.fields(o);
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			if(f == "pregap") {
				continue;
			}
			if(Object.prototype.hasOwnProperty.call(this,f)) {
				Reflect.setProperty(this,f,Reflect.field(o,f));
			}
		}
		if(o.pregap != null) {
			this.pregap = new cd_CueTime();
			this.pregap.fromJSON(o.pregap);
		}
		this.indexes = [];
		let oInd = o.indexes;
		let _g2 = 0;
		while(_g2 < oInd.length) {
			let i = oInd[_g2];
			++_g2;
			let ind = new cd_CueTime();
			ind.fromJSON(i);
			this.indexes.push(ind);
		}
	}
}
cd_CDTrack.__name__ = true;
Object.assign(cd_CDTrack.prototype, {
	__properties__: {set_trackType: "set_trackType"}
});
class cd_CueTime {
	constructor(n,m,s,f) {
		if(f == null) {
			f = 0;
		}
		if(s == null) {
			s = 0;
		}
		if(m == null) {
			m = 0;
		}
		if(n == null) {
			n = 0;
		}
		this.no = n;
		this.minutes = m;
		this.seconds = s;
		this.frames = f;
	}
	toFrames() {
		return this.seconds * 75 + this.minutes * 60 * 75 + this.frames;
	}
	fromFrames(f) {
		this.minutes = Math.floor(f / 4500);
		this.seconds = Math.floor(f % 4500 / 75);
		this.frames = f % 75;
		return this;
	}
	toString() {
		return StringTools.lpad("" + this.minutes,"0",2) + ":" + StringTools.lpad("" + this.seconds,"0",2) + ":" + StringTools.lpad("" + this.frames,"0",2);
	}
	fromJSON(o) {
		let _g = 0;
		let _g1 = Reflect.fields(o);
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			this[f] = Reflect.field(o,f);
		}
	}
}
cd_CueTime.__name__ = true;
class djA_ArrayExecSync {
	constructor(ar) {
		this.items = ar;
	}
	start(ONITEM,ONCOMPLETE) {
		this.C = -1;
		if(ONITEM != null) {
			this.onItem = ONITEM;
		}
		if(ONCOMPLETE != null) {
			this.onComplete = ONCOMPLETE;
		}
		this.next();
	}
	next() {
		if(++this.C < this.items.length) {
			this.onItem(this.items[this.C]);
			return;
		} else if(this.onComplete != null) {
			this.onComplete();
			return;
		}
	}
}
djA_ArrayExecSync.__name__ = true;
class djA_DataT {
	static existsOr(a,v) {
		if(a == null) {
			return v;
		}
		return a;
	}
	static bytesToMBStr(bytes) {
		return Std.string(Math.ceil(bytes / 1048576));
	}
}
djA_DataT.__name__ = true;
class djA_StrT {
	static isEmpty(str) {
		if(str != null) {
			return str.length == 0;
		} else {
			return true;
		}
	}
	static rep(len,symbol) {
		return StringTools.lpad("",symbol,len);
	}
	static padString(str,length,align,char) {
		if(char == null) {
			char = " ";
		}
		if(align == null) {
			align = "l";
		}
		let b = length - str.length;
		if(b == 0) {
			return str;
		}
		if(b < 0) {
			return str.substring(0,length - 1) + djA_StrT.OVERFLOW_SMBL;
		}
		switch(align) {
		case "c":
			let _l = Math.ceil(b / 2);
			let _r = Math.floor(b / 2);
			str = StringTools.rpad("",char,_l) + str + StringTools.rpad("",char,_r);
			break;
		case "r":
			str = StringTools.lpad(str,char,length);
			break;
		default:
			str = StringTools.rpad(str,char,length);
		}
		return str;
	}
}
djA_StrT.__name__ = true;
var djNode_KeycodeID = $hxEnums["djNode.KeycodeID"] = { __ename__ : true, __constructs__ : ["up","down","left","right","home","insert","delete","end","pageup","pagedown","backsp","tab","enter","space","esc","ctrlC","acute","F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","other"]
	,up: {_hx_index:0,__enum__:"djNode.KeycodeID",toString:$estr}
	,down: {_hx_index:1,__enum__:"djNode.KeycodeID",toString:$estr}
	,left: {_hx_index:2,__enum__:"djNode.KeycodeID",toString:$estr}
	,right: {_hx_index:3,__enum__:"djNode.KeycodeID",toString:$estr}
	,home: {_hx_index:4,__enum__:"djNode.KeycodeID",toString:$estr}
	,insert: {_hx_index:5,__enum__:"djNode.KeycodeID",toString:$estr}
	,'delete': {_hx_index:6,__enum__:"djNode.KeycodeID",toString:$estr}
	,end: {_hx_index:7,__enum__:"djNode.KeycodeID",toString:$estr}
	,pageup: {_hx_index:8,__enum__:"djNode.KeycodeID",toString:$estr}
	,pagedown: {_hx_index:9,__enum__:"djNode.KeycodeID",toString:$estr}
	,backsp: {_hx_index:10,__enum__:"djNode.KeycodeID",toString:$estr}
	,tab: {_hx_index:11,__enum__:"djNode.KeycodeID",toString:$estr}
	,enter: {_hx_index:12,__enum__:"djNode.KeycodeID",toString:$estr}
	,space: {_hx_index:13,__enum__:"djNode.KeycodeID",toString:$estr}
	,esc: {_hx_index:14,__enum__:"djNode.KeycodeID",toString:$estr}
	,ctrlC: {_hx_index:15,__enum__:"djNode.KeycodeID",toString:$estr}
	,acute: {_hx_index:16,__enum__:"djNode.KeycodeID",toString:$estr}
	,F1: {_hx_index:17,__enum__:"djNode.KeycodeID",toString:$estr}
	,F2: {_hx_index:18,__enum__:"djNode.KeycodeID",toString:$estr}
	,F3: {_hx_index:19,__enum__:"djNode.KeycodeID",toString:$estr}
	,F4: {_hx_index:20,__enum__:"djNode.KeycodeID",toString:$estr}
	,F5: {_hx_index:21,__enum__:"djNode.KeycodeID",toString:$estr}
	,F6: {_hx_index:22,__enum__:"djNode.KeycodeID",toString:$estr}
	,F7: {_hx_index:23,__enum__:"djNode.KeycodeID",toString:$estr}
	,F8: {_hx_index:24,__enum__:"djNode.KeycodeID",toString:$estr}
	,F9: {_hx_index:25,__enum__:"djNode.KeycodeID",toString:$estr}
	,F10: {_hx_index:26,__enum__:"djNode.KeycodeID",toString:$estr}
	,F11: {_hx_index:27,__enum__:"djNode.KeycodeID",toString:$estr}
	,F12: {_hx_index:28,__enum__:"djNode.KeycodeID",toString:$estr}
	,other: {_hx_index:29,__enum__:"djNode.KeycodeID",toString:$estr}
};
class djNode_Keycode {
	static toKeyCodeID(key) {
		if(HxOverrides.cca(key,1) == null) {
			switch(HxOverrides.cca(key,0)) {
			case 3:
				return djNode_KeycodeID.ctrlC;
			case 8:
				return djNode_KeycodeID.backsp;
			case 9:
				return djNode_KeycodeID.tab;
			case 13:
				return djNode_KeycodeID.enter;
			case 27:
				return djNode_KeycodeID.esc;
			case 32:
				return djNode_KeycodeID.space;
			case 96:
				return djNode_KeycodeID.acute;
			case 127:
				return djNode_KeycodeID.backsp;
			}
		} else if(HxOverrides.cca(key,0) == 27 && HxOverrides.cca(key,1) == 91) {
			switch(HxOverrides.cca(key,2)) {
			case 49:
				switch(HxOverrides.cca(key,3)) {
				case 55:
					return djNode_KeycodeID.F6;
				case 56:
					return djNode_KeycodeID.F7;
				case 57:
					return djNode_KeycodeID.F8;
				case 126:
					return djNode_KeycodeID.home;
				}
				break;
			case 50:
				switch(HxOverrides.cca(key,3)) {
				case 48:
					return djNode_KeycodeID.F9;
				case 49:
					return djNode_KeycodeID.F10;
				case 51:
					return djNode_KeycodeID.F11;
				case 52:
					return djNode_KeycodeID.F12;
				case 126:
					return djNode_KeycodeID.insert;
				}
				break;
			case 51:
				return djNode_KeycodeID.delete;
			case 52:
				return djNode_KeycodeID.end;
			case 53:
				return djNode_KeycodeID.pageup;
			case 54:
				return djNode_KeycodeID.pagedown;
			case 65:
				return djNode_KeycodeID.up;
			case 66:
				return djNode_KeycodeID.down;
			case 67:
				return djNode_KeycodeID.right;
			case 68:
				return djNode_KeycodeID.left;
			case 91:
				switch(HxOverrides.cca(key,3)) {
				case 65:
					return djNode_KeycodeID.F1;
				case 66:
					return djNode_KeycodeID.F2;
				case 67:
					return djNode_KeycodeID.F3;
				case 68:
					return djNode_KeycodeID.F4;
				case 69:
					return djNode_KeycodeID.F5;
				}
				break;
			}
		}
		return null;
	}
}
djNode_Keycode.__name__ = true;
class djNode_Keyboard {
	static startCapture(realtime,callback) {
		if(realtime == null) {
			realtime = true;
		}
		djNode_Keyboard.stop();
		if(callback != null) {
			djNode_Keyboard.onData = callback;
		}
		djNode_Keyboard.stdin = process.stdin;
		djNode_Keyboard.stdin.setRawMode(realtime);
		djNode_Keyboard.stdin.setEncoding("utf8");
		djNode_Keyboard.stdin.on("data",djNode_Keyboard.onKeyData);
		djNode_Keyboard.stdin.resume();
	}
	static onKeyData(data) {
		if(djNode_Keyboard.FLAG_CAN_BREAK && data == djNode_Keycode.CTRLC) {
			djNode_Keyboard.stop();
			if(djNode_Keyboard.onBreak != null) {
				djNode_Keyboard.onBreak();
			}
			djNode_Keyboard.onBreak = null;
			return;
		}
		if(djNode_Keyboard.onData != null) {
			djNode_Keyboard.onData(data);
		}
	}
	static stop() {
		if(djNode_Keyboard.stdin == null) {
			return;
		}
		djNode_Keyboard.stdin.pause();
		djNode_Keyboard.stdin.setRawMode(false);
		djNode_Keyboard.stdin.removeAllListeners("data");
	}
	static flush() {
		if(djNode_Keyboard.stdin == null) {
			return;
		}
		djNode_Keyboard.stdin.pause();
		djNode_Keyboard.stdin.resume();
	}
	static readOnceSync() {
		let SIZE = 512;
		let b = js_node_buffer_Buffer.alloc(SIZE);
		let bytesin = 0;
		bytesin = 0;
		try {
			bytesin = js_node_Fs.readSync(process.stdin.fd,b,0,SIZE,null);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			throw haxe_Exception.thrown(e);
		}
		return b.toString("utf8",0,bytesin - 2);
	}
}
djNode_Keyboard.__name__ = true;
var djNode_TColor = $hxEnums["djNode.TColor"] = { __ename__ : true, __constructs__ : ["black","white","gray","red","green","blue","yellow","cyan","magenta","darkgray","darkred","darkgreen","darkblue","darkyellow","darkcyan","darkmagenta"]
	,black: {_hx_index:0,__enum__:"djNode.TColor",toString:$estr}
	,white: {_hx_index:1,__enum__:"djNode.TColor",toString:$estr}
	,gray: {_hx_index:2,__enum__:"djNode.TColor",toString:$estr}
	,red: {_hx_index:3,__enum__:"djNode.TColor",toString:$estr}
	,green: {_hx_index:4,__enum__:"djNode.TColor",toString:$estr}
	,blue: {_hx_index:5,__enum__:"djNode.TColor",toString:$estr}
	,yellow: {_hx_index:6,__enum__:"djNode.TColor",toString:$estr}
	,cyan: {_hx_index:7,__enum__:"djNode.TColor",toString:$estr}
	,magenta: {_hx_index:8,__enum__:"djNode.TColor",toString:$estr}
	,darkgray: {_hx_index:9,__enum__:"djNode.TColor",toString:$estr}
	,darkred: {_hx_index:10,__enum__:"djNode.TColor",toString:$estr}
	,darkgreen: {_hx_index:11,__enum__:"djNode.TColor",toString:$estr}
	,darkblue: {_hx_index:12,__enum__:"djNode.TColor",toString:$estr}
	,darkyellow: {_hx_index:13,__enum__:"djNode.TColor",toString:$estr}
	,darkcyan: {_hx_index:14,__enum__:"djNode.TColor",toString:$estr}
	,darkmagenta: {_hx_index:15,__enum__:"djNode.TColor",toString:$estr}
};
class djNode_Terminal {
	constructor() {
		this.PARSED_NOTAG = "";
		this.ENABLE_NOTAG = true;
		let _g = new haxe_ds_EnumValueMap();
		_g.set(djNode_TColor.darkgray,"\x1B[90m");
		_g.set(djNode_TColor.red,"\x1B[91m");
		_g.set(djNode_TColor.green,"\x1B[92m");
		_g.set(djNode_TColor.yellow,"\x1B[93m");
		_g.set(djNode_TColor.blue,"\x1B[94m");
		_g.set(djNode_TColor.magenta,"\x1B[95m");
		_g.set(djNode_TColor.cyan,"\x1B[96m");
		_g.set(djNode_TColor.white,"\x1B[97m");
		_g.set(djNode_TColor.black,"\x1B[30m");
		_g.set(djNode_TColor.darkred,"\x1B[31m");
		_g.set(djNode_TColor.darkgreen,"\x1B[32m");
		_g.set(djNode_TColor.darkyellow,"\x1B[33m");
		_g.set(djNode_TColor.darkblue,"\x1B[34m");
		_g.set(djNode_TColor.darkmagenta,"\x1B[35m");
		_g.set(djNode_TColor.darkcyan,"\x1B[36m");
		_g.set(djNode_TColor.gray,"\x1B[37m");
		this.COLORS_FG = _g;
		let _g1 = new haxe_ds_EnumValueMap();
		_g1.set(djNode_TColor.darkgray,"\x1B[100m");
		_g1.set(djNode_TColor.red,"\x1B[101m");
		_g1.set(djNode_TColor.green,"\x1B[102m");
		_g1.set(djNode_TColor.yellow,"\x1B[103m");
		_g1.set(djNode_TColor.blue,"\x1B[104m");
		_g1.set(djNode_TColor.magenta,"\x1B[105m");
		_g1.set(djNode_TColor.cyan,"\x1B[106m");
		_g1.set(djNode_TColor.white,"\x1B[107m");
		_g1.set(djNode_TColor.black,"\x1B[40m");
		_g1.set(djNode_TColor.darkred,"\x1B[41m");
		_g1.set(djNode_TColor.darkgreen,"\x1B[42m");
		_g1.set(djNode_TColor.darkyellow,"\x1B[43m");
		_g1.set(djNode_TColor.darkblue,"\x1B[44m");
		_g1.set(djNode_TColor.darkmagenta,"\x1B[45m");
		_g1.set(djNode_TColor.darkcyan,"\x1B[46m");
		_g1.set(djNode_TColor.gray,"\x1B[47m");
		this.COLORS_BG = _g1;
	}
	fg(col) {
		if(col == null) {
			process.stdout.write("\x1B[39m");
			return this;
		}
		let str = this.COLORS_FG.get(col);
		process.stdout.write(str);
		return this;
	}
	bold() {
		process.stdout.write("\x1B[1m");
		return this;
	}
	clearLine(type) {
		if(type == null) {
			type = 2;
		}
		process.stdout.write("\x1B[" + type + "K");
		return this;
	}
	cursorShow() {
		process.stdout.write("\x1B[?25h");
		return this;
	}
	ptag(s) {
		let str = this.parseTags(s);
		process.stdout.write(str);
		return this;
	}
	parseTags(str) {
		let _gthis = this;
		let res = new EReg("<(\\S+?)>","g").map(str,function(reg) {
			let src = reg.matched(1);
			let prop = src.split(",");
			let ret = "";
			let _g = 0;
			while(_g < prop.length) {
				let p = prop[_g];
				++_g;
				let ret1;
				switch(p) {
				case "!":
					ret1 = "\x1B[0m";
					break;
				case "!bg":
					ret1 = "\x1B[49m";
					break;
				case "!blink":
					ret1 = "\x1B[25m";
					break;
				case "!bold":
					ret1 = "\x1B[21m";
					break;
				case "!dim":
					ret1 = "\x1B[22m";
					break;
				case "!fg":
					ret1 = "\x1B[39m";
					break;
				case "!underl":
					ret1 = "\x1B[24m";
					break;
				case "blink":
					ret1 = "\x1B[5m";
					break;
				case "bold":
					ret1 = "\x1B[1m";
					break;
				case "cr":
					ret1 = "\x1B[u";
					break;
				case "cs":
					ret1 = "\x1B[s";
					break;
				case "dim":
					ret1 = "\x1B[2m";
					break;
				case "underl":
					ret1 = "\x1B[4m";
					break;
				default:
					if(p.indexOf(":") == 0) {
						try {
							ret1 = _gthis.COLORS_BG.get(Type.createEnum(djNode_TColor,p.split(":")[1],null));
						} catch( _g ) {
							throw haxe_Exception.thrown("Tag Error: Color does not exist in `" + src + "`");
						}
					} else {
						try {
							ret1 = _gthis.COLORS_FG.get(Type.createEnum(djNode_TColor,p,null));
						} catch( _g ) {
							ret1 = reg.matched(0);
						}
					}
				}
				ret += ret1;
			}
			return ret;
		});
		if(this.ENABLE_NOTAG) {
			this.PARSED_NOTAG = new EReg("<(\\S+?)>","g").map(str,function(reg) {
				return "";
			});
		}
		return res;
	}
}
djNode_Terminal.__name__ = true;
class djNode_app_PismoMount {
	static mount(p,drive) {
		if(drive != null) {
			let res = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " mount -i -m " + drive + " \"" + p + "\"");
			return "" + drive + ":\\";
		}
		let res0 = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " mount -i \"" + p + "\"");
		let res1 = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " list \"" + p + "\"");
		let reg = new EReg(".*(?:\\.zip|\\.pfo|\\.cfs) (.*)","ig");
		if(reg.match(res1)) {
			return reg.matched(1);
		} else {
			return null;
		}
	}
	static unmount(p) {
		try {
			let s = p == null ? "" : "\"" + p + "\"";
			let a = djNode_utils_CLIApp.quickExecS("" + djNode_app_PismoMount.EXE + " unmount " + s);
			if(a != null) {
				return true;
			}
		} catch( _g ) {
		}
		return false;
	}
	static CFS_SetExe(path) {
		if(path == null) {
			djNode_app_PismoMount.PTISO = js_node_Path.join(process.env["ProgramW6432"],"Pismo File Mount Audit Package","ptiso.exe");
		} else {
			djNode_app_PismoMount.PTISO = js_node_Path.join(path,"ptiso.exe");
		}
	}
	static CFS_CreateAsync(files,target,callback,onProgress) {
		let app = new djNode_utils_CLIApp(djNode_app_PismoMount.PTISO);
		let f0 = false;
		let ex0 = new EReg("(Writing file data)","");
		let ex1 = new EReg("\\stime.+byte\\s(.*)\\sof\\s(.*\\d)","");
		if(onProgress != null) {
			app.onStdOut = function(data) {
				if(!f0) {
					if(ex0.match(data)) {
						f0 = true;
					}
					return;
				}
				if(ex1.match(data)) {
					let a0 = Std.parseInt(StringTools.replace(ex1.matched(1),".",""));
					let a1 = Std.parseInt(StringTools.replace(ex1.matched(2),".",""));
					onProgress(a0 / a1 * 100 | 0);
				}
			};
		}
		app.onClose = function(s) {
			callback(s);
		};
		let result = new Array(files.length);
		let _g = 0;
		let _g1 = files.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = "file {" + files[i] + "}";
		}
		let filesP = result;
		app.start(["create","-f","-t","ciso","-z","lzma",target].concat(filesP));
	}
}
djNode_app_PismoMount.__name__ = true;
class djNode_tools_FileTool {
	static deleteRecursiveDir(dir_path) {
		if(djNode_tools_FileTool.pathExists(dir_path)) {
			let contents = js_node_Fs.readdirSync(dir_path);
			let _g = 0;
			while(_g < contents.length) {
				let entry = contents[_g];
				++_g;
				let entry_path = js_node_Path.join(dir_path,entry);
				if(js_node_Fs.lstatSync(entry_path).isDirectory()) {
					djNode_tools_FileTool.deleteRecursiveDir(entry_path);
				} else {
					js_node_Fs.unlinkSync(entry_path);
				}
			}
			js_node_Fs.rmdirSync(dir_path);
		}
	}
	static pathExists(path) {
		try {
			js_node_Fs.statSync(path);
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof Error)) {
				return false;
			} else {
				throw _g;
			}
		}
		return true;
	}
	static getFileListFromDir(inPath,fullPath) {
		if(fullPath == null) {
			fullPath = false;
		}
		let allfiles = js_node_Fs.readdirSync(js_node_Path.normalize(inPath));
		let ret = [];
		let _g = 0;
		while(_g < allfiles.length) {
			let f = allfiles[_g];
			++_g;
			if(js_node_Fs.statSync(js_node_Path.join(inPath,f)).isFile()) {
				if(fullPath) {
					ret.push(js_node_Path.join(inPath,f));
				} else {
					ret.push(f);
				}
			}
		}
		return ret;
	}
	static getFileListFromWildcard(path) {
		let fileList = [];
		let basePath = js_node_Path.dirname(path);
		let extToGet = djNode_tools_FileTool.getFileExt(path);
		let baseToGet;
		let exp = new EReg("(\\S*)\\.","");
		if(exp.match(js_node_Path.basename(path))) {
			baseToGet = exp.matched(1);
			if(baseToGet.length > 1 && baseToGet.indexOf("*") > 0) {
				throw haxe_Exception.thrown("Advanced search is currently unsupported, use basic [*.*] or [*.ext]");
			}
		} else {
			baseToGet = "*";
		}
		let allfiles = js_node_Fs.readdirSync(js_node_Path.normalize(basePath));
		let stats;
		let _g = 0;
		while(_g < allfiles.length) {
			let i = allfiles[_g];
			++_g;
			try {
				stats = js_node_Fs.statSync(js_node_Path.join(basePath,i));
			} catch( _g ) {
				continue;
			}
			if(stats.isFile()) {
				if(baseToGet != "*") {
					if(exp.match(i)) {
						if(baseToGet != exp.matched(1)) {
							continue;
						}
					} else {
						continue;
					}
				}
				if(extToGet == ".*") {
					fileList.push(js_node_Path.join(basePath,i));
					continue;
				}
				if(extToGet == js_node_Path.extname(i).toLowerCase()) {
					fileList.push(js_node_Path.join(basePath,i));
					continue;
				}
			}
		}
		return fileList;
	}
	static getFileExt(file) {
		return js_node_Path.extname(file).toLowerCase();
	}
}
djNode_tools_FileTool.__name__ = true;
class djNode_tools_LOG {
	static init() {
		if(djNode_tools_LOG._isInited) {
			return;
		}
		djNode_tools_LOG._isInited = true;
		djNode_tools_LOG.messages = [];
	}
	static end() {
		if(djNode_tools_LOG.flag_socket_log) {
			djNode_tools_LOG.io.close();
		}
	}
	static log(obj,level,d) {
		if(level == null) {
			level = 1;
		}
		if(level < djNode_tools_LOG.logLevel) {
			return;
		}
		let logmsg = { pos : null, log : Std.string(obj), level : level};
		if(djNode_tools_LOG.BUFFER_SIZE > 0 && djNode_tools_LOG.messages.length >= djNode_tools_LOG.BUFFER_SIZE) {
			djNode_tools_LOG.messages.shift();
		}
		djNode_tools_LOG.messages.push(logmsg);
		if(djNode_tools_LOG.flag_socket_log) {
			djNode_tools_LOG.io.sockets.emit("logText",{ data : logmsg.log, pos : logmsg.pos, level : logmsg.level});
		}
		if(djNode_tools_LOG.logFile != null) {
			djNode_tools_LOG.push_File(logmsg);
		}
		if(djNode_tools_LOG.onLog != null) {
			djNode_tools_LOG.onLog(logmsg);
		}
		if(djNode_tools_LOG.FLAG_STDOUT) {
			let _this = djNode_BaseApp.TERMINAL;
			let str = logmsg.log;
			process.stdout.write(str + "\n");
		}
	}
	static push_File(log) {
		let m = "";
		if(djNode_tools_LOG.FLAG_SHOW_MESSAGE_TYPE) {
			m += djNode_tools_LOG.messageTypes[log.level] + " ";
		}
		m += log.log + "\n";
		try {
			js_node_Fs.appendFileSync(djNode_tools_LOG.logFile,m,"utf8");
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof Error)) {
				djNode_BaseApp.TERMINAL.ptag("<red> - NO SPACE LEFT FOR THE LOG FILE - <!>\n");
				process.exit(1);
			} else {
				throw _g;
			}
		}
	}
}
djNode_tools_LOG.__name__ = true;
class djNode_utils_CLIApp {
	constructor(exec,path) {
		if(path == null) {
			path = "";
		}
		this.FLAG_ERRORS_ON_STDERR = false;
		this.LOG_STDOUT = true;
		this.LOG_STDERR = true;
		this.exePath = js_node_Path.join(path,exec);
	}
	start(args,workingDir) {
		let _gthis = this;
		if(args == null) {
			args = [];
		}
		this.log_last_call = "" + this.exePath + " " + args.join(" ");
		if(!djNode_utils_CLIApp.FLAG_LOG_QUIET) {
			djNode_tools_LOG.log("RUN: " + this.log_last_call);
		}
		this.proc = js_node_ChildProcess.spawn(this.exePath,args,{ cwd : workingDir});
		this.proc.once("error",function(er) {
			_gthis.kill();
			_gthis.ERROR = "Exit Error : " + er.message;
			djNode_tools_LOG.log("Process `" + _gthis.exePath + "` [ ERROR ] - " + _gthis.ERROR,3);
			if(_gthis.onClose != null) {
				_gthis.onClose(false);
			}
		});
		this.proc.once("close",function(code,killsig) {
			_gthis.kill();
			if(code != 0) {
				let r = _gthis.FLAG_ERRORS_ON_STDERR ? _gthis.stdErrLog : _gthis.stdOutLog;
				let _this_r = new RegExp("(\\s\\s+|\n)","g".split("u").join(""));
				let c = r.replace(_this_r,"");
				_gthis.ERROR = "ExitCode:(" + code + ") , StdOut/Err:" + HxOverrides.substr(c,-80,null);
				djNode_tools_LOG.log("Process `" + _gthis.exePath + "` End - [ ERROR ] - " + _gthis.ERROR,3);
				if(_gthis.onClose != null) {
					_gthis.onClose(false);
				}
			} else {
				if(!djNode_utils_CLIApp.FLAG_LOG_QUIET) {
					djNode_tools_LOG.log("Process `" + _gthis.exePath + "` End - [ OK ]");
				}
				if(_gthis.onClose != null) {
					_gthis.onClose(true);
				}
			}
		});
		this.stdOutLog = "";
		this.stdErrLog = "";
		if(this.onStdErr != null) {
			this.proc.stderr.setEncoding("utf8");
			this.proc.stderr.on("data",this.onStdErr);
		}
		if(this.onStdOut != null) {
			this.proc.stdout.setEncoding("utf8");
			this.proc.stdout.on("data",this.onStdOut);
		}
		if(this.LOG_STDERR) {
			this.proc.stderr.setEncoding("utf8");
			this.proc.stderr.on("data",function(d) {
				let _gthis1 = _gthis;
				_gthis1.stdErrLog += d;
				return _gthis1.stdErrLog;
			});
		}
		if(this.LOG_STDOUT) {
			this.proc.stdout.setEncoding("utf8");
			this.proc.stdout.on("data",function(d) {
				let _gthis1 = _gthis;
				_gthis1.stdOutLog += d;
				return _gthis1.stdOutLog;
			});
		}
	}
	kill() {
		if(this.proc != null) {
			this.proc.removeAllListeners();
			this.proc.kill();
			this.proc = null;
		}
	}
	static quickExecS(path,cwd) {
		try {
			if(!djNode_utils_CLIApp.FLAG_LOG_QUIET) {
				djNode_tools_LOG.log("ExecSync : " + path + " | cwd : " + (cwd == null ? process.cwd() : cwd));
			}
			return js_node_ChildProcess.execSync(path,{ cwd : cwd, stdio : ["ignore","pipe","ignore"]});
		} catch( _g ) {
			return null;
		}
	}
	static checkRun(execStr) {
		try {
			let pr = js_node_ChildProcess.execSync(execStr,{ timeout : 10000, stdio : "ignore"});
			return true;
		} catch( _g ) {
			return false;
		}
	}
}
djNode_utils_CLIApp.__name__ = true;
class djNode_utils_Print2 {
	constructor() {
		this.lpad = 0;
		this.T = djNode_BaseApp.TERMINAL;
	}
	H(text,size) {
		if(size == null) {
			size = 0;
		}
		let s = djNode_utils_Print2.H_STYLES[size];
		this.lpad = s.pad0;
		this.ptem(s.templ,text);
		if(s.line != null) {
			let r = s.line.split(":");
			let l = Std.parseInt(r[0]);
			if(l == 1) {
				l = this.T.PARSED_NOTAG.length;
			}
			if(l > 0) {
				this.T.fg(Type.createEnum(djNode_TColor,r[1],null));
				if(this.lpad > 0) {
					let _this = this.T;
					let x = this.lpad;
					if(x == null) {
						x = 1;
					}
					process.stdout.write("\x1B[" + x + "C");
				}
				let _this = this.T;
				let str = djA_StrT.rep(l,"─");
				process.stdout.write(str + "\n");
				let _this1 = this.T;
				process.stdout.write("\x1B[39m");
			}
		}
		this.lpad = s.pad1;
	}
	p(text) {
		if(this.lpad > 0) {
			let _this = this.T;
			let x = this.lpad;
			if(x == null) {
				x = 1;
			}
			process.stdout.write("\x1B[" + x + "C");
		}
		let _this = this.T.ptag(text);
		process.stdout.write("\n");
		return this;
	}
	line(len) {
		if(len == null) {
			len = 40;
		}
		if(this.lpad > 0) {
			let _this = this.T;
			let x = this.lpad;
			if(x == null) {
				x = 1;
			}
			process.stdout.write("\x1B[" + x + "C");
		}
		let _this = this.T;
		let str = djA_StrT.rep(len,"─");
		process.stdout.write(str + "\n");
		return this;
	}
	ptem(tem,t1,t2,t3) {
		this.p(this.parseTempl(tem,t1,t2,t3));
	}
	parseTempl(tem,t1,t2,t3) {
		let r = new EReg("\\{(\\d+):?(\\d+)?\\}","g");
		return r.map(tem,function(r1) {
			let m = r.matched(1);
			let part;
			let _g = Std.parseInt(m);
			if(_g == null) {
				throw haxe_Exception.thrown("Templates support up to three(3) capture groups");
			} else {
				switch(_g) {
				case 1:
					part = t1;
					break;
				case 2:
					part = t2;
					break;
				case 3:
					part = t3;
					break;
				default:
					throw haxe_Exception.thrown("Templates support up to three(3) capture groups");
				}
			}
			if(r1.matched(2) != null) {
				part = djA_StrT.padString(part,Std.parseInt(r1.matched(2)));
			}
			return part;
		});
	}
}
djNode_utils_Print2.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
Object.assign(haxe_Exception.prototype, {
	__properties__: {get_native: "get_native"}
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_ds_BalancedTree {
	constructor() {
	}
	set(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	get(key) {
		let node = this.root;
		while(node != null) {
			let c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	setLoop(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		let c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			let nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			let nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	balance(l,k,v,r) {
		let hl = l == null ? 0 : l._height;
		let hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			let _this = l.left;
			let _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			let _this = r.right;
			let _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	compare(k1,k2) {
		return Reflect.compare(k1,k2);
	}
}
haxe_ds_BalancedTree.__name__ = true;
class haxe_ds_TreeNode {
	constructor(l,k,v,r,h) {
		if(h == null) {
			h = -1;
		}
		this.left = l;
		this.key = k;
		this.value = v;
		this.right = r;
		if(h == -1) {
			let tmp;
			let _this = this.left;
			let _this1 = this.right;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				let _this = this.left;
				tmp = _this == null ? 0 : _this._height;
			} else {
				let _this = this.right;
				tmp = _this == null ? 0 : _this._height;
			}
			this._height = tmp + 1;
		} else {
			this._height = h;
		}
	}
}
haxe_ds_TreeNode.__name__ = true;
class haxe_ds_EnumValueMap extends haxe_ds_BalancedTree {
	constructor() {
		super();
	}
	compare(k1,k2) {
		let d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		let p1 = Type.enumParameters(k1);
		let p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	compareArgs(a1,a2) {
		let ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		let _g = 0;
		let _g1 = a1.length;
		while(_g < _g1) {
			let i = _g++;
			let d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	compareArg(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
}
haxe_ds_EnumValueMap.__name__ = true;
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
}
haxe_io_Bytes.__name__ = true;
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
haxe_io_Eof.__name__ = true;
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	static directory(path) {
		let s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static extension(path) {
		let s = new haxe_io_Path(path);
		if(s.ext == null) {
			return "";
		}
		return s.ext;
	}
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		let _g2 = paths;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		let paths1 = _g;
		if(paths1.length == 0) {
			return "";
		}
		let path = paths1[0];
		let _g3 = 1;
		let _g4 = paths1.length;
		while(_g3 < _g4) {
			let i = _g3++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += paths1[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let tmp = target.join(slash);
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g2_offset = 0;
		let _g2_s = tmp;
		while(_g2_offset < _g2_s.length) {
			let s = _g2_s;
			let index = _g2_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g2_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
haxe_io_Path.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let n = e.__constructs__[o._hx_index];
				let con = e[n];
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
var js_node_ChildProcess = require("child_process");
var js_node_Fs = require("fs");
class js_node_KeyValue {
	static get_key(this1) {
		return this1[0];
	}
	static get_value(this1) {
		return this1[1];
	}
}
js_node_KeyValue.__properties__ = {get_value: "get_value",get_key: "get_key"};
var js_node_Os = require("os");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
class js_node_stream_WritableNewOptionsAdapter {
	static from(options) {
		if(!Object.prototype.hasOwnProperty.call(options,"final")) {
			Object.defineProperty(options,"final",{ get : function() {
				return options.final_;
			}});
		}
		return options;
	}
}
class js_node_url_URLSearchParamsEntry {
	static _new(name,value) {
		let this1 = [name,value];
		return this1;
	}
	static get_name(this1) {
		return this1[0];
	}
	static get_value(this1) {
		return this1[1];
	}
}
js_node_url_URLSearchParamsEntry.__properties__ = {get_value: "get_value",get_name: "get_name"};
class sys_FileSystem {
	static exists(path) {
		try {
			js_node_Fs.accessSync(path);
			return true;
		} catch( _g ) {
			return false;
		}
	}
}
sys_FileSystem.__name__ = true;
class sys_io_FileInput extends haxe_io_Input {
	constructor(fd) {
		super();
		this.fd = fd;
		this.pos = 0;
	}
	readByte() {
		let buf = js_node_buffer_Buffer.alloc(1);
		let bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	readBytes(s,pos,len) {
		let data = s.b;
		let buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		let bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( _g ) {
			let e = haxe_Exception.caught(_g).unwrap();
			if(e.code == "EOF") {
				throw haxe_Exception.thrown(new haxe_io_Eof());
			} else {
				throw haxe_Exception.thrown(haxe_io_Error.Custom(e));
			}
		}
		if(bytesRead == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
	seek(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	tell() {
		return this.pos;
	}
	eof() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
}
sys_io_FileInput.__name__ = true;
class sys_io_FileOutput extends haxe_io_Output {
	constructor(fd) {
		super();
		this.fd = fd;
		this.pos = 0;
	}
	writeByte(b) {
		let buf = js_node_buffer_Buffer.alloc(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	writeBytes(s,pos,len) {
		let data = s.b;
		let buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		let wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	close() {
		js_node_Fs.closeSync(this.fd);
	}
	seek(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	tell() {
		return this.pos;
	}
}
sys_io_FileOutput.__name__ = true;
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__ : true, __constructs__ : ["SeekBegin","SeekCur","SeekEnd"]
	,SeekBegin: {_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
js_Boot.__toStr = ({ }).toString;
djNode_BaseApp._hx_skip_constructor = false;
djNode_BaseApp.VERSION = "0.6";
djNode_BaseApp.LINE_LEN = 40;
cd_CDInfos.VERSION = 4;
cd_CDInfos.NEWLINE = "\n";
cd_CDInfos.SUPPORTED_TRACK_FILES = ["BINARY","WAVE"];
djA_StrT.OVERFLOW_SMBL = "-";
djNode_Keycode.CTRLC = "\x03";
djNode_Keycode.ESC = "\x1B";
djNode_Keycode.UP = "\x1B[A";
djNode_Keycode.DOWN = "\x1B[B";
djNode_Keycode.LEFT = "\x1B[C";
djNode_Keycode.RIGHT = "\x1B[D";
djNode_Keycode.BACKSP = "\x08";
djNode_Keycode.TAB = "\t";
djNode_Keycode.ENTER = "\r";
djNode_Keycode.DELETE = "";
djNode_Keyboard.FLAG_CAN_BREAK = true;
djNode_app_PismoMount.EXE = "pfm.exe";
djNode_app_PismoMount.PTISO = "ptiso.exe";
djNode_tools_LOG.messageTypes = ["DEBUG","INFO","WARN","ERROR","FATAL"];
djNode_tools_LOG._isInited = false;
djNode_tools_LOG.logLevel = 0;
djNode_tools_LOG.flag_socket_log = false;
djNode_tools_LOG.FLAG_SHOW_MESSAGE_TYPE = false;
djNode_tools_LOG.FLAG_STDOUT = false;
djNode_tools_LOG.BUFFER_SIZE = 8000;
djNode_utils_CLIApp.FLAG_LOG_QUIET = true;
djNode_utils_Print2.H_STYLES = [{ templ : "<cyan>>> <bold,white,:darkblue> {1} <!>", pad0 : 1, pad1 : 4, line : null},{ templ : "<:blue,black> > <!> <blue>{1}<!>", pad0 : 4, pad1 : 7, line : null}];
Main.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
